"""Generate xrandr commands and xinitrc blocks with modeline support."""

import math
from typing import List, Optional
from .detector import DisplayDetector, Monitor, Resolution
from .modeutils import ModeUtils
from bootstrap.gui.logging import Logger

logger = Logger(__name__)


class XrandrCommandGenerator:
    def __init__(self):
        self.logger = logger
        self.detector = DisplayDetector()

    # modeline generation is delegated to modeutils.get_modeline

    def _generate_monitor_sequence(self, m: Monitor, target: Resolution) -> List[str]:
        cmds: List[str] = []
        rate = int(target.refresh_rate) if target.refresh_rate else 60
        mode_name = f"{target.width}x{target.height}_{rate}"

        # Try direct mode set
        if self.detector.xrandr_available:
            cmds.append(f"xrandr --output {m.name} --mode {target.width}x{target.height} --rate {rate}{' --primary' if m.primary else ''}")

        # Modeline fallback/newmode: prefer system cvt/gtf, fallback to python
        edid_path = getattr(m, 'edid_path', None)
        model = ModeUtils.get_modeline(target.width, target.height, rate, edid_path)
        if model:
            mode_name_ret, params = model
            # use returned mode name if available, else our constructed name
            final_name = mode_name_ret or mode_name
            cmds.append(f"xrandr --newmode \"{final_name}\" {params}")
            cmds.append(f"xrandr --addmode {m.name} \"{final_name}\"")
            cmds.append(f"xrandr --output {m.name} --mode \"{final_name}\" --rate {rate}{' --primary' if m.primary else ''}")

        return cmds

    def generate_commands(self) -> str:
        monitors = self.detector.get_connected_monitors()

        if not monitors:
            self.logger.warning("No connected monitors detected")
            return ""

        commands: List[str] = []

        primary = self.detector.get_primary_monitor()
        if primary:
            seq = self._generate_monitor_sequence(primary, self.detector.get_best_resolution(primary) or Resolution(2560, 1440, 60.0))
            for cmd in seq:
                commands.append(cmd)
            self.logger.info(f"Primary monitor: {primary.name}")

        for monitor in monitors:
            if monitor != primary:
                best = self.detector.get_best_resolution(monitor)
                if not best and monitor.edid_size == 0:
                    best = Resolution(2560, 1440, 60.0)
                if not best:
                    self.logger.debug(f"No suitable resolution for {monitor.name}")
                    continue
                seq = self._generate_monitor_sequence(monitor, best)
                for cmd in seq:
                    commands.append(cmd)
                self.logger.info(f"Secondary monitor: {monitor.name}")

        return '\n'.join(commands)

    def generate_xinitrc_section(self) -> str:
        commands = self.generate_commands()

        if not commands:
            self.logger.warning("No display commands generated")
            return ""

        lines = [
            "# [DISPLAY_CONFIG_START]",
            "# Autogenerated display config - do not edit",
            "if command -v xrandr >/dev/null 2>&1; then",
            *[f"  {cmd}" for cmd in commands.split('\n')],
            "fi",
            "# [DISPLAY_CONFIG_END]",
        ]

        return '\n'.join(lines) + '\n'
